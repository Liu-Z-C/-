# 《数据库原理与运用》课程自我评价

## 第一周：
给自己打8.4分，因为觉得数据库有1.6。

**本周学习**  
- 学习了数据库系统的基本概念、发展历史以及其在现代软件架构中的核心地位。如果没有数据库系统的话，就只能将记录存储在不同的文件中，并需要不同的应用程序来处理文件，这显然有很多缺点。
- 理解了数据、数据库（DB）、数据库管理系统（DBMS）和数据库系统（DBS）之间的区别与联系：  
  - **数据**：是对客观事物的符号表示，是数据库中存储和处理的基本对象。  
  - **数据库（DB）**：是有组织、可共享的数据集合，按照一定的数据模型存储在计算机中。  
  - **数据库管理系统（DBMS）**：是一套用于定义、创建、管理和维护数据库的软件系统，负责数据的存储、检索、安全和完整性等。  
  - **数据库系统（DBS）**：是指由数据库、DBMS、相关应用程序和数据库管理员等组成的完整系统。  
  - **联系**：数据是最基本的元素，数据库是数据的有序集合，DBMS 是管理数据库的软件，数据库系统则包含了数据库、DBMS 以及相关人员和应用，是一个完整的运行环境。


**疑惑与解决**  
- 最初困惑于“为什么 Excel 不能算作数据库系统？”  
  通过查阅资料，明白了 DBMS 提供了持久化存储、事务管理、并发控制和高阶查询语言等复杂功能，保证了数据的正确性(Correctness)、一致性(Consistency)和安全性(Security)。而excel算是文件处理系统。



---

## 第二周：
给自己打8分，在课上并未完全掌握关系代数的核心思路，而在课后的练习中找到了感觉。

**本周学习**  
- 学习了关系模型的核心——关系代数。
- 了解了了并、交、差、笛卡尔积、选择、投影、连接等基本运算。
- 理解了主码、候选码、超码和外码的概念及其重要性。

**技术细节**  
- 关系代数是数据库查询优化的逻辑基础。
- SQL 语句会被查询优化器转化为等价且更高效的关系代数表达式树。

**疑惑与解决**  
- 在刚接触关系代数的时候，感觉不太直观，特别是笛卡尔积。后面通过寻找网上的教程以及阅读教材慢慢搞懂了其中的逻辑。

---

## 第三周：
给自己打10分，认为自己较好地掌握了基本的sql语句以及编程逻辑。

**本周学习**  
- 学习了 SQL 的 DDL（数据定义语言）和 DQL（数据查询语言）基本用法。

**技术细节与探索**  
- 了解到 `SELECT *` 在生产环境中应避免，明确指定所需列是有效的优化手段。
- 在课后尝试了一些简单的sql语句
![第三周SQL练习](pictures/屏幕截图%202025-06-11%20112147.png)

---

## 第四周：实验室软件实际操作（PostgreSQL）
给自己打7.5分，因为虽然完成了 PostgreSQL 的安装和基本配置，但在实际操作过程中遇到了一些环境变量和软件兼容性的问题，花费了较多时间排查和解决。此外，初次接触专业数据库管理工具（如 DATAGRIP），对其界面和功能还不够熟悉，操作效率有待提升。不过通过不断尝试和查阅资料，最终顺利完成了数据库的导入和基本操作，提升了动手能力和问题解决能力。

**本周学习**  
- 安装并配置了 PostgreSQL，并在DATAGRIP软件中运行。
- 掌握了DATAGRIP的基本操作，并使用它创建了大学数据库，并导入了数据。

**疑惑与解决**  
- 配置 PATH 环境变量遇到问题，最终通过系统环境变量设置解决。
- 在导入数据时发现运行速度很慢，询问老师后发现应该使用批量导入，成功解决了该问题。
---

## 第五周：
给自己打8分，因为虽然掌握了 SQL 中 NULL 的含义、聚集函数和分组操作，但在where，having和三值逻辑判断上还有一些困惑，经过课后查阅资料和练习才逐步理解相关概念。
**本周学习**  
- 学习了 SQL 中 NULL 的含义及三值逻辑。
- 掌握了聚集函数和 GROUP BY、HAVING 的用法。

**技术细节与探索**  
- 发现 COUNT(*) 计算所有行数，COUNT(column_name) 只计算非空行。

**疑惑与解决**  
- 关于where和having何时可以互相替代感到疑惑，查阅资料发现：
  - WHERE 子句用于在分组和聚合之前筛选原始数据行，不能包含聚合函数。
  - HAVING 子句用于在分组和聚合之后筛选分组结果，可以包含聚合函数。
  - 当查询没有 GROUP BY 且 HAVING 不涉及聚合时，WHERE 和 HAVING 的效果类似，但推荐使用 WHERE。
  - 一般情况下，聚合前过滤用 WHERE，聚合后过滤用 HAVING，不能随意互换。
- 关于null的数据类型在sql里面相当特殊，关于其逻辑的判断没有太听懂。在询问ai后得到结论：
  - 在SQL中，NULL 表示“未知”或“缺失”的值，不等同于0或空字符串。
  - 任何与NULL参与的比较（如 `=`, `<>`, `>`, `<` 等）结果都是 UNKNOWN，而不是 TRUE 或 FALSE。
  - 判断某个字段是否为NULL，必须使用 `IS NULL` 或 `IS NOT NULL`，不能用 `= NULL`。
  - 聚合函数（如 COUNT、SUM、AVG）在处理NULL时会自动忽略NULL值。
  - WHERE子句中的条件如果结果为UNKNOWN，则该行不会被选中。

---

## 第六周：
给自己打7分，因为虽然掌握了数据库的增删改操作和事务控制的基本用法，但在实际操作中仍然出现过误删数据等问题。
**本周学习**  
- 掌握了 INSERT、UPDATE、DELETE 语句，能够熟练地对数据库表进行数据的新增、修改和删除操作，理解了每种语句的基本语法和常见用法。

**技术细节与探索**  
- 了解到批量插入数据时应优先使用 COPY 命令，相比多次执行 INSERT，COPY 能显著提升大数据量导入的效率，适合实际生产环境的数据初始化和迁移场景。
- 学习了事务的基本概念，明白了在执行多条数据修改语句时，应该使用 BEGIN、COMMIT、ROLLBACK 等事务控制命令来保证数据的一致性和安全性。

**疑惑与解决**  
- 忘记 WHERE 子句导致误删数据，借助事务 ROLLBACK 恢复，养成了先 SELECT 检查的习惯。通过这次失误，深刻体会到在执行 UPDATE 或 DELETE 语句前，务必先用 SELECT 语句确认筛选条件，避免误操作带来的数据损失。
---

## 第七、八周：
给自己打7分，因为认为自己没有完全弄懂多表查询和各种 JOIN 的底层原理，尤其是在实际编写复杂 SQL 时容易混淆不同 JOIN 的用法和结果。虽然能够理解 INNER JOIN、LEFT JOIN、RIGHT JOIN、FULL JOIN 等基本语法，但在面对多表关联和嵌套查询时，仍然会出现理解偏差和调试困难。

**两周学习**  
- 第七周学习了多表查询的核心 JOIN，包括多种 JOIN 类型，掌握了基本的连接语法和常见的多表查询场景。
- 第八周实验课，通过实践操作进一步加深对JOIN使用方法的理解。

**技术细节与探索**  
- 理解了索引对 JOIN 性能的影响，知道了在大表关联时合理建立索引可以显著提升查询效率。

**疑惑与解决**  
- 发现 NATURAL JOIN 存在隐患，容易因字段重名导致错误匹配，决定今后始终使用 ON 子句明确连接条件，保证查询的可读性和安全性。
- 通过查阅官方文档和实际操作，逐步理清了各类 JOIN 的适用场景和注意事项，但对复杂多表连接的优化和调优还需进一步实践和学习。
---

## 第九周：
给自己打9分，这一周感觉自己对 PostgreSQL 的数据类型有了更深入的理解，尤其是日期时间、小数精度、自增主键和类型转换这些内容，虽然有些细节一开始没搞明白，但通过查资料和多做实验，最后都弄清楚了，收获很大。

**本周学习**  
- 这一周主要学习了 PostgreSQL 里的日期和时间类型，比如 DATE、TIME、TIMESTAMP，搞清楚了它们各自的用法和区别。
- 还遇到了小数精度的问题，专门研究了 NUMERIC、DECIMAL、FLOAT 这些类型，明白了什么时候该用高精度类型，什么时候可以用浮点数。
- 学会了 serial 这种自增主键的写法，知道了它其实是 integer 加 sequence 的组合。
- 还尝试了自定义数据类型，并了解了类型转换（CAST）的各种写法和注意事项。

**技术细节与探索**  
- 实际操作中发现，日期和时间类型在存储、比较和格式化时有很多细节，尤其是时区和格式化输出。
- 浮点数类型（FLOAT、DOUBLE PRECISION）在做运算时有精度丢失的问题，适合科学计算但不适合做财务相关的数据。
- serial 虽然用起来很方便，但底层其实是自动创建了一个序列，理解了它的原理后用起来更轻松了。
- 还学会了用 CREATE TYPE 创建枚举类型和复合类型，类型转换的时候可以用 :: 或 CAST，两种写法都挺常见。

**疑惑与解决**  
- 一开始用 FLOAT 存钱，结果发现算出来的小数总有点不对劲，后来查了官方文档才知道要用 NUMERIC 或 DECIMAL 才能保证精度。
- 自定义类型和类型转换时，遇到了一些语法上的错误，多试几次加上查资料，最后都搞明白了。
---

## 第十周：
给自己打8.5分，这周虽然一开始对函数和过程的区别有点懵，但通过查资料和多写代码，最后基本都搞明白了，感觉收获挺大。

**本周学习**  
- 这一周主要学习了怎么在 PostgreSQL 里写自定义函数和过程，弄清楚了两者的定义方式和用法区别。以前总觉得函数和过程差不多，这次算是彻底分清了。
- 学习了如何定义函数（CREATE FUNCTION），包括参数、返回值和语言（如 SQL、PL/pgSQL）的选择。
- 学习了如何定义过程（CREATE PROCEDURE），了解了过程可以没有返回值，适合做批量操作和流程控制。
- 还顺便了解了触发器（TRIGGER）的用法，知道了可以用 CREATE TRIGGER 让数据库在插入、更新、删除时自动执行某些操作，比如自动记录日志或者校验数据。

**函数和过程的区别**  
- 函数（FUNCTION）一般有返回值，可以在 SELECT 语句或表达式中调用，适合做计算和返回结果。
- 过程（PROCEDURE）可以没有返回值，主要用于执行一系列操作或批量处理，通常用 CALL 语句调用，不能直接在 SELECT 里用。
- 函数更偏向于“算一个值”，过程更偏向于“做一件事”，而且过程可以包含事务控制（如 COMMIT、ROLLBACK），函数里一般不建议这么做。

**技术细节与探索**  
- 还专门研究了函数的易变性（Volatility）属性，比如 IMMUTABLE、STABLE、VOLATILE，发现这个属性会影响查询优化器的执行计划，写函数的时候要注意声明对不对，不然可能影响性能。
- 试着用 SQL 和 PL/pgSQL 写了几个简单的函数和过程，体会到了过程可以有控制流程（比如 IF、LOOP），而函数更适合做计算和返回值。
- 触发器用起来也挺有意思，比如可以自动给表加“最后更新时间”字段，或者实现一些自动化的数据校验。
![过程的练习代码](pictures/屏幕截图%202025-06-12%20105257.png)
![运行结果](pictures/屏幕截图%202025-06-12%20105340.png)
**疑惑与解决**  
- 一开始不太明白函数和过程到底啥区别，后来查了官方文档和网上的例子，发现函数一般有返回值，过程可以没有返回值，而且过程可以直接用 CALL 调用，函数要用 SELECT 或在表达式里用。
- 写触发器的时候一开始老是忘记要先写触发函数（trigger function），多试几次才搞明白触发器和普通函数的区别。
- 实际写代码时还踩了点语法坑，比如过程不能直接在 SELECT 里用，函数不能直接用 CALL，搞清楚这些细节后用起来顺手多了。
---

## 第十一周：
给自己打9分，这周主要学到了从外部调用sql，感觉很实用，且在实践中体会到了数据库安全的重要性，尤其是防止 SQL 注入攻击这一块，感觉非常有收获。

**本周学习**  
- 学会了用 Python 的 psycopg2 库去连接和操作 PostgreSQL 数据库，能写出基本的增删改查脚本，还能处理查询结果。
- 了解了 SQL 注入攻击的原理，明白了如果直接拼接字符串写 SQL 语句，用户输入恶意内容就可能导致数据泄露或被篡改。
- 了解了什么是参数化查询，知道了只有用参数化的方式才能真正防止 SQL 注入。

**技术细节与探索**  
- 实际写代码时，尝试了用字符串拼接和参数化两种方式，发现参数化不仅更安全，还能自动处理类型转换，写起来也更省心。
- 通过查阅 psycopg2 的官方文档，掌握了 execute 方法的参数用法，知道了 %s 占位符和传参的正确姿势。


**疑惑与解决**  
- 一开始觉得拼接 SQL 语句很方便，但在查资料和实验后，发现这样做风险很大，尤其是面对用户输入时。
---

## 第十二周：
给自己打7.5分，因为一开始觉得ER模型挺抽象的，画ER图的时候总是分不清实体和属性，实际转化为关系模式时也容易出错。不过通过画案例、查资料和多练习，慢慢理清了思路，能比较顺利地把实际需求转成ER图并进一步设计表结构了，感觉进步很大，但还有提升空间。
**本周学习**  
- 这一周主要学习了实体-关系（ER）模型，明白了什么是实体、属性、联系，以及它们在数据库设计中的作用。
- 学会了怎么把现实世界的需求抽象成 ER 图，比如用矩形表示实体、椭圆表示属性、菱形表示联系。
- 还学习了如何把 ER 图转化为关系模式，为后续的表结构设计打下基础。
- 学习到了使用draw.io软件绘制ER图

**技术细节与探索**  
- 通过画 ER 图，发现用图形化的方式能更直观地理清数据之间的关系，避免后期表结构混乱。
- 了解了强实体、弱实体、1对多、多对多等不同联系类型，以及它们在实际建表时的处理方式。

**疑惑与解决**  
- 一开始觉得 ER 图有点抽象，不知道实际用处。后来通过简化案例（比如个人博客系统），把用户、文章、评论等实体和它们之间的关系画出来，才真正体会到 ER 图在数据库设计中的价值。
- 在转化为关系模式时，遇到多对多关系的处理有点疑惑，查资料后明白了要用中间表来实现。

---

## 第十三周：
给自己打8.5分，因为感觉自己对理论部分（比如范式、函数依赖这些）理解更加清晰。

**本周学习**  
- 深入学习了函数依赖理论，理解了什么是一范式、二范式、三范式、BCNF等各级范式。
- 学会了如何判断一个关系模式是否满足某个范式，以及如何通过分解消除冗余和异常。
- 理解了无损连接分解的判断方法，知道了分解时要保证数据不会丢失。

**技术细节与探索**  
- 在判断一个关系模式是否满足某个范式时，首先要分析所有的函数依赖关系，然后结合主码和候选码的定义，逐步检查是否存在部分依赖、传递依赖或不满足主属性要求的情况。
- 判断一范式（1NF）主要看每个属性值是否都是不可再分的原子值。
- 判断二范式（2NF）时，需要确保每个非主属性都完全依赖于主码，而不是主码的一部分（即消除部分依赖）。
- 判断三范式（3NF）时，要求每个非主属性不仅完全依赖于主码，还不能传递依赖于主码（即消除传递依赖）。
- 判断BCNF时，要求每个决定因素都是候选码，进一步消除了依赖异常。
- 实际操作中，可以通过写出所有的函数依赖、找出主码和候选码，然后逐条对照范式定义来判断，复杂时可以画依赖图或写属性闭包辅助分析。

**疑惑与解决**  
- 一开始对无损连接分解的判断标准有点模糊，后来通过做题和查资料，总结出一个规律：只要分解后的公共属性是任一子关系的超码，这个分解就是无损的。
- 在实际分析复杂依赖时，发现画依赖图和写出闭包能帮助理清思路。
---

## 第十四、十五、十六周:

给自己打8分，因为学习的数据库底层理论比较抽象，尤其是在存储和索引部分，花了较多时间才深入理解。

**本周学习**
* **数据库存储**：学习了数据库的物理存储方式。数据被组织在固定大小的 Page 中，这些 Page 进一步构成文件。了解了两种核心的存储模型：将元组所有属性连续存放的 行存储 (NSM) 和将单个属性连续存放的 列存储 (DSM)。
* **数据库索引**：理解了索引是用于提升数据检索速度的数据结构。主要学习了两种索引类型：有序索引和哈希索引。其中，B+ 树索引作为一种平衡树结构，能保证高效的查询性能，而哈希索引则非常适用于等值查询场景。
* **查询与事务**：掌握了查询处理的基本步骤，包括解析、优化和执行。深入学习了事务 (Transaction) 这一核心概念，它作为单个逻辑工作单元，需满足 ACID 四大特性：原子性 (Atomicity)、一致性 (Consistency) 和持久性 (Durability)。

***

**技术细节与探索**

* 深入研究后发现，索引虽然能极大地提升查询速度，但并非没有代价。在进行数据写入（如 `INSERT`、`UPDATE`、`DELETE`）时，系统需要付出额外的开销来维护索引数据结构，这可能会影响写入性能。因此，在设计数据库时，需要权衡索引带来的查询增益与维护成本。

***

**疑惑与解决**

* 起初对于为什么在某些场景下数据更新操作会比较慢感到困惑。通过学习索引原理后明白，更新操作不仅要修改数据本身，还必须同步更新所有相关的索引结构以保证数据一致性。这个维护成本是导致性能变化的关键原因，加深了我对性能优化的理解。


# 最终打分
最终打分依据保证满分为50分，则将每周的自我评价分数加起来除以3，最终得到：40.5分
